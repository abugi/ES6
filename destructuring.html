<script>
     /* 
     destructing in ES6 simply refers to a way of extracting data from arrays and objects.
     */

     //extracting data from arrays
     const names = ['Luke', 'Eva', 'Phil', 'Ander', 'Jason', 'Bally'];
     const [name] = names; 
     const [name1, name2, ...rest] = names;
     
     console.log(name)
     console.log(name1, name2, rest);
     let m = rest.push('Alice');
     console.log(rest);

     //default values when elements are missing
     newNames = ['amisco', 'shareefat', 'maryam'];
     const [first, second, third, fourth] = newNames;  
     console.log(fourth); // undefined

     const [one, two, three, four = 'nameMissing'] = newNames;
     console.log(one, two, three, four);

     //skipping elements in the array
     var [fn, , tn] = names;  
     console.log(fn, tn); // 'Luke' 'Phil' (eva skipped)

     //destructuring objects
     const person = {  
          personName: 'Luke',
          personAge: '24',
          facts: {
          hobby: 'Photo',
          work: 'Software Developer'
          }
     }

     const {personName, personAge} = person;  //in  the case of objects, we use curly braces on the left
     console.log(personName, personAge); // 'Luke' '24' 

     //extracting nested values
     const {facts: {work}} = person;  
     console.log(work); 

     //setting default value for when data is missing
     const {hometown = 'Unknown'} = person;  
     console.log(hometown); // 'Unknown'

     //destructuring function parameters
     const toString = ({personName, personAge}) => {  
     return `${personName} is ${personAge} years old`;
     }

     console.log(toString(person)); // Luke is 24 years old

     /* 
       In a normal object literal, the object properties (target) are specified first, then the
       source value.
     */
     var X = 10, Y = 20;
          var o = { a: X, b: Y };
          console.log( o.a, o.b ); // 10 20

     /*
       in a destructuring assingment however, the order is flipped in that we have the source value first
       then target.
     */
     var aa = 10, bb = 20;
     var o = { x: aa, y: bb };
     var { x: AA, y: BB } = o;
     console.log( AA, BB ); // 10 20

     /*
       There’s another way to think about this syntax though, which may help ease the confusion.
       Consider:
     */
     var aa = 10, bb = 20;
     var o = { x: aa, y: bb };
     var { x: AA, y: BB } = o;
     console.log( AA, BB ); // 10 20

     /*
     In the { x: aa, y: bb } line, the x and y represent the object properties. In the { x:
     AA, y: BB } line, the x and the y also represent the object properties.
     Recall earlier I asserted that { x, .. } was leaving off the x: part? In those two lines,
     if you erase the x: and y: parts in that snippet, you’re left only with aa, bb, AA, and BB,
     which in effect are assignments from aa to AA and from bb to BB. That’s actually what
     we’ve accomplished with the snippet.
     So, that symmetry may help to explain why the syntactic pattern was intentionally
     flipped for this ES6 feature.
     */
</script>