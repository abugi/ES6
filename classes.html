<script>
     /*
     Some JavaScript values have other values associated with them. These associations
     are called properties. Every string, for example, has a property called
     length, which refers to an integer, the amount of characters in that string.
     Properties can be accessed in two ways, either with brackets or using dot
     notation:
     */
     var text = "purple haze";
     text["length"]; //11
     text.length; //11
     /*
     The dot notation is a shorthand for the bracket notation, and it works only when the
     name of the property is a valid variable name—when it doesn’t have any
     spaces or symbols in it and does not start with a digit character.
     Trying to read a property from the values null and undefined will cause
     an error. Numbers and Booleans do have properties, but none of them is
     interesting or useful enough to be discussed here.
     */

     //Object Values
     /*
     In most value types, if they have properties at all, they are fixed, and you are
     not allowed to change them. (A string’s length always stays the same, for example.)
     However, there is one type of value, objects, where properties can be
     freely added, removed, and changed. The main role of objects, in fact, is to
     be a collection of properties.
     An object can be written like this:
     */
     var cat = {color: "gray", name: "Spot", size: 46};
     cat.size = 47;
     cat.size; //47
     delete cat.size;
     cat.size; //undefined

     /*
     Prototypes are a powerful, if somewhat confusing, part of
     the way JavaScript objects work. Every object is based on a prototype, which
     gives it a set of inherent properties. The simple objects we have used so far
     are based on the most basic prototype, which is associated with the Object
     constructor, and are thus shared by all objects. (Typing {}, by the way, is
     equivalent to typing new Object().)
     */
     function Rabbit(adjective) {
     this.adjective = adjective;
     this.speak = function(line) {
     print("The ", this.adjective, " rabbit says '", line, "'");
     };
     }
     var killerRabbit = new Rabbit("killer");
     killerRabbit.speak("GRAAAAAAAAAH!");
     //It is convention to start the names of constructors with a capital letter.

     /*
     Constructors and Prototypes
     Our rabbit objects are based on the prototype associated with the Rabbit
     constructor. You can use a constructor’s prototype property to access this
     prototype.
     Every function you define automatically gets a prototype property,
     which holds an object—the prototype of the function. This prototype gets
     a constructor property, which points back at the function to which it belongs.
     Because the rabbit prototype is itself an object, it is based on the Object prototype
     and shares its toString method. Thus, any rabbit created with the
     Rabbit constructor has this method.
     Even though objects seem to share the properties of their prototype,
     this sharing is one-way. The properties of the prototype influence the object
     based on it, and changes to these objects never affect the prototype.
     The precise rules are these: When looking up the value of a property,
     JavaScript first looks at the properties that the object itself has. If there is a
     property that has the name we are looking for, that is the value we get. If
     there is no such property, it continues searching the prototype of the object,
     and then the prototype of the prototype, and so on. If no property is found,
     the value undefined is given. On the other hand, when setting the value of a
     property, JavaScript never goes to the prototype but always sets the property
     in the object itself. This means you can “override” properties in your own
     objects to give them more specific, appropriate values than the generic ones
     it takes from its prototype. The following code demonstrates this technique:
     */
     Rabbit.prototype.teeth = "small";
     killerRabbit.teeth; //"small"
     killerRabbit.teeth = "long, sharp, and bloody";
     killerRabbit.teeth; //"long, sharp, and bloody"
     Rabbit.prototype.teeth; //"small"

     //Javacript classes
    /* JavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript's existing prototype-based inheritance. The class syntax is not introducing a new object-oriented inheritance model to JavaScript. JavaScript classes provide a much simpler and clearer syntax to create objects and deal with inheritance.
    */

    // Defining classesEdit
     /*Classes are in fact "special functions", and just as you can define function expressions and function declarations, the class syntax has two components: class expressions and class declarations.
     */

</script>